from dataclasses import dataclass, field
from typing import Dict, Tuple, List, Callable, Any, Optional
import heapq
import csv

@dataclass(order=True)
class PrioritizedItem:
    priority: float
    node: Any=field(compare=False)

@dataclass
class Edge:
    target: str
    line: str
    time: float

@dataclass
class Node:
    name: str
    edges: List[Edge]

class Graph:
    """Simple graph structure to store nodes and weighted edges."""
    def __init__(self):
        self.nodes: Dict[str, Node] = {}

    def add_edge(self, source: str, target: str, line: str, time: float) -> None:
        if source not in self.nodes:
            self.nodes[source] = Node(name=source, edges=[])
        if target not in self.nodes:
            self.nodes[target] = Node(name=target, edges=[])
        self.nodes[source].edges.append(Edge(target=target, line=line, time=time))

    def neighbors(self, node: str) -> List[Edge]:
        return list(self.nodes.get(node, Node(name=node, edges=[])).edges)


def parse_travel_time(td_str: str) -> float:
    """Convert a ``travel_time_to_next_stop`` string to minutes."""
    if not td_str:
        return 0.0
    parts = td_str.strip().split(" days ")
    if len(parts) == 2:
        days, time_part = parts
    else:
        days, time_part = "0", parts[0]
    hours, minutes, seconds = map(int, time_part.split(":"))
    return int(days) * 1440 + hours * 60 + minutes + seconds / 60.0


def load_graph_from_csv(path: str) -> Graph:
    """Create a graph from a CSV generated by GTFS with travel times."""
    g = Graph()
    with open(path, newline="", encoding="utf-8") as fh:
        reader = csv.DictReader(fh)
        prev_row = None
        for row in reader:
            if prev_row and row["trip_id"] == prev_row["trip_id"]:
                source = prev_row["stop_name"]
                target = row["stop_name"]
                line = row["route_short_name"]
                travel_time = parse_travel_time(prev_row["travel_time_to_next_stop"])
                g.add_edge(source, target, line, travel_time)
            prev_row = row
    return g

def astar(
    graph: Graph,
    start: str,
    goal: str,
    heuristic: Callable[[str, str], float],
    time_weight: float = 1.0,
    transfer_penalty: float = 5.0,
) -> Optional[List[Tuple[str, Optional[str]]]]:
    """Compute shortest path using A* algorithm with line awareness.

    Args:
        graph: Graph object containing nodes and weighted edges.
        start: Node name where the route begins.
        goal: Destination node name.
        heuristic: Function estimating cost from a node to the goal.
        time_weight: Multiplier applied to the travel time of each edge.
        transfer_penalty: Additional cost when switching lines.

    Returns:
        List of tuples ``(stop, line)`` representing the path. The first
        element's line is ``None`` because no line has been taken yet. ``None``
        is returned if no path exists.
    """
    open_set: List[PrioritizedItem] = []
    start_state = (start, None)
    heapq.heappush(open_set, PrioritizedItem(priority=0, node=start_state))

    came_from: Dict[Tuple[str, Optional[str]], Optional[Tuple[str, Optional[str]]]] = {}
    g_score: Dict[Tuple[str, Optional[str]], float] = {start_state: 0}

    while open_set:
        current_state = heapq.heappop(open_set).node
        current_node, current_line = current_state
        if current_node == goal:
            path = []
            while True:
                path.append(current_state)
                prev = came_from.get(current_state)
                if prev is None:
                    break
                current_state = prev
            return list(reversed(path))

        for edge in graph.neighbors(current_node):
            neighbor_state = (edge.target, edge.line)
            transfer_cost = 0
            if current_line is not None and edge.line != current_line:
                transfer_cost = transfer_penalty

            tentative_g_score = (
                g_score[(current_node, current_line)]
                + edge.time * time_weight
                + transfer_cost
            )

            if tentative_g_score < g_score.get(neighbor_state, float("inf")):
                came_from[neighbor_state] = (current_node, current_line)
                g_score[neighbor_state] = tentative_g_score
                f_score = tentative_g_score + heuristic(edge.target, goal)
                heapq.heappush(
                    open_set,
                    PrioritizedItem(priority=f_score, node=neighbor_state),
                )

    return None

# Example heuristic: straight-line distance (requires coordinate lookup)
def null_heuristic(node: str, goal: str) -> float:
    return 0

if __name__ == "__main__":
    # Load graph from CSV file. Fallback to the test file if the full file is
    # not present.
    csv_file = "Vollst√§ndige_CSV_mit_Zeiten.csv"
    try:
        graph = load_graph_from_csv(csv_file)
    except FileNotFoundError:
        print(f"CSV '{csv_file}' not found. Using test data instead.")
        graph = load_graph_from_csv("Test_CSV_with_travel_times.csv")

    start = input("Start stop name: ").strip()
    goal = input("Goal stop name: ").strip()

    choice = input("Sort route by time or transfers? [time/transfers]: ").strip().lower()
    if choice.startswith("time"):
        time_weight = 1.0
        penalty = 0.1
    elif choice.startswith("transfers"):
        time_weight = 0.0
        penalty = 1.0
    else:
        print("Invalid choice. Defaulting to time.")
        time_weight = 1.0
        penalty = 0.1


    path = astar(
        graph,
        start,
        goal,
        heuristic=null_heuristic,
        time_weight=time_weight,
        transfer_penalty=penalty,
    )

    if path:
        print("Found path:")
        for stop, line in path:
            line_str = line if line is not None else "start"
            print(f"{stop} via {line_str}")
    else:
        print("No path found.")

from dataclasses import dataclass, field
from typing import Dict, Tuple, List, Callable, Any, Optional
import heapq
import csv
from datetime import datetime
import difflib

@dataclass(order=True)
class PrioritizedItem:
    priority: float
    node: Any=field(compare=False)

@dataclass
class Edge:
    target: str
    line: str
    departure: float
    travel_time: float

@dataclass
class Node:
    name: str
    edges: List[Edge]

class Graph:
    """Simple graph structure to store nodes and weighted edges."""
    def __init__(self):
        self.nodes: Dict[str, Node] = {}

    def add_edge(self, source: str, target: str, line: str, departure: float, travel_time: float) -> None:
        if source not in self.nodes:
            self.nodes[source] = Node(name=source, edges=[])
        if target not in self.nodes:
            self.nodes[target] = Node(name=target, edges=[])
        self.nodes[source].edges.append(
            Edge(target=target, line=line, departure=departure, travel_time=travel_time)
        )

    def neighbors(self, node: str) -> List[Edge]:
        return list(self.nodes.get(node, Node(name=node, edges=[])).edges)

    def reversed(self) -> "Graph":
        """Return a new graph with all edges reversed.

        The ``departure`` of the reversed edge corresponds to the arrival time
        at the original target stop.
        """
        rev = Graph()
        for source, node in self.nodes.items():
            for edge in node.edges:
                arrival = edge.departure + edge.travel_time
                rev.add_edge(edge.target, source, edge.line, arrival, edge.travel_time)
        return rev


def parse_travel_time(td_str: str) -> float:
    """Convert a ``travel_time_to_next_stop`` string to minutes.

    The GTFS data usually stores times either in ``HH:MM:SS`` or
    ``"<days> days HH:MM:SS"`` format.  For convenience when taking user
    input we also allow ``HH:MM`` where seconds are assumed to be ``00``.
    """

    if not td_str:
        return 0.0

    parts = td_str.strip().split(" days ")
    if len(parts) == 2:
        days, time_part = parts
    else:
        days, time_part = "0", parts[0]

    time_parts = time_part.split(":")
    if len(time_parts) == 3:
        hours, minutes, seconds = map(int, time_parts)
    elif len(time_parts) == 2:
        hours, minutes = map(int, time_parts)
        seconds = 0
    else:
        raise ValueError(f"Invalid time format: {td_str}")

    return int(days) * 1440 + hours * 60 + minutes + seconds / 60.0


def parse_time_to_minutes(time_str: str) -> float:
    """Parse a ``departure_time`` or ``arrival_time`` field to minutes."""
    return parse_travel_time(time_str)


def minutes_to_hhmm(minutes: float) -> str:
    """Format minutes past midnight as ``HH:MM``."""
    minutes = minutes % (24 * 60)
    hours = int(minutes // 60)
    mins = int(minutes % 60)
    return f"{hours:02d}:{mins:02d}"


def resolve_stop(query: str, stop_names: List[str], cutoff: float = 0.6) -> Optional[str]:
    """Return the closest matching stop name for ``query`` or ``None``."""
    matches = difflib.get_close_matches(query, stop_names, n=1, cutoff=cutoff)
    return matches[0] if matches else None


def load_graph_from_csv(path: str) -> Graph:
    """Create a graph from a CSV generated by GTFS with travel times."""
    g = Graph()
    with open(path, newline="", encoding="utf-8") as fh:
        reader = csv.DictReader(fh)
        prev_row = None
        for row in reader:
            if prev_row and row["trip_id"] == prev_row["trip_id"]:
                source = prev_row["stop_name"]
                target = row["stop_name"]
                line = row["route_short_name"]
                travel_time = parse_travel_time(prev_row["travel_time_to_next_stop"])
                departure = parse_time_to_minutes(prev_row["departure_time"])
                g.add_edge(source, target, line, departure, travel_time)
            prev_row = row
    return g

def astar(
    graph: Graph,
    start: str,
    goal: str,
    heuristic: Callable[[str, str], float],
    start_time: float,
    time_weight: float = 1.0,
    transfer_penalty: float = 5.0,
) -> Optional[List[Tuple[str, Optional[str], float]]]:
    """Compute shortest path using A* algorithm with line awareness.

    Args:
        graph: Graph object containing nodes and weighted edges.
        start: Node name where the route begins.
        goal: Destination node name.
        heuristic: Function estimating cost from a node to the goal.
        time_weight: Multiplier applied to the travel time of each edge.
        transfer_penalty: Additional cost when switching lines.

    Returns:
        List of tuples ``(stop, line, arrival_time)`` representing the path.
        The first element's line is ``None`` because no line has been taken
        yet. ``None`` is returned if no path exists. ``arrival_time`` is the
        actual arrival time in minutes past midnight, without any penalties.
    """
    open_set: List[PrioritizedItem] = []
    start_state = (start, None)
    heapq.heappush(open_set, PrioritizedItem(priority=start_time, node=start_state))

    came_from: Dict[Tuple[str, Optional[str]], Optional[Tuple[str, Optional[str]]]] = {}
    g_score: Dict[Tuple[str, Optional[str]], float] = {start_state: start_time}
    arrival_times: Dict[Tuple[str, Optional[str]], float] = {start_state: start_time}

    while open_set:
        current_state = heapq.heappop(open_set).node
        current_node, current_line = current_state
        if current_node == goal:
            path = []
            while True:
                arr = arrival_times[current_state]
                stop, line = current_state
                path.append((stop, line, arr))
                prev = came_from.get(current_state)
                if prev is None:
                    break
                current_state = prev
            return list(reversed(path))

        current_time = g_score[(current_node, current_line)]
        current_arrival = arrival_times[(current_node, current_line)]
        for edge in graph.neighbors(current_node):
            if edge.departure < current_arrival:
                continue
            neighbor_state = (edge.target, edge.line)
            transfer_cost = 0
            if current_line is not None and edge.line != current_line:
                transfer_cost = transfer_penalty

            arrival_actual = edge.departure + edge.travel_time
            arrival_time = edge.departure + edge.travel_time * time_weight
            tentative_g_score = arrival_time + transfer_cost

            if tentative_g_score < g_score.get(neighbor_state, float("inf")):
                came_from[neighbor_state] = (current_node, current_line)
                g_score[neighbor_state] = tentative_g_score
                arrival_times[neighbor_state] = arrival_actual
                f_score = tentative_g_score + heuristic(edge.target, goal)
                heapq.heappush(
                    open_set,
                    PrioritizedItem(priority=f_score, node=neighbor_state),
                )

    return None


def astar_reverse(
    graph: Graph,
    start: str,
    goal: str,
    heuristic: Callable[[str, str], float],
    arrival_time: float,
    time_weight: float = 1.0,
    transfer_penalty: float = 5.0,
) -> Optional[List[Tuple[str, Optional[str], float]]]:
    """Backward search variant of ``astar``.

    This function searches from ``goal`` towards ``start`` in order to find the
    latest possible departure time that still results in an arrival at
    ``goal`` by ``arrival_time``.

    Returns:
        A list of tuples ``(stop, line, arrival_time)`` representing the path
        from ``start`` to ``goal``. ``arrival_time`` denotes the time at which
        the traveller must be at ``stop`` when following the computed route.
        ``None`` is returned if no path exists.
    """

    rev_graph = graph.reversed()

    open_set: List[PrioritizedItem] = []
    start_state = (goal, None)
    heapq.heappush(open_set, PrioritizedItem(priority=-arrival_time, node=start_state))

    came_from: Dict[Tuple[str, Optional[str]], Optional[Tuple[str, Optional[str]]]] = {}
    best_time: Dict[Tuple[str, Optional[str]], float] = {start_state: arrival_time}
    arrival_times: Dict[Tuple[str, Optional[str]], float] = {start_state: arrival_time}

    while open_set:
        current_state = heapq.heappop(open_set).node
        current_node, current_line = current_state
        if current_node == start:
            path: List[Tuple[str, Optional[str], float]] = []
            next_line: Optional[str] = current_state[1]
            while True:
                arr = arrival_times[current_state]
                stop, line = current_state
                path.append((stop, None if not path else next_line, arr))
                next_line = line
                prev = came_from.get(current_state)
                if prev is None:
                    break
                current_state = prev
            return path

        current_time = best_time[current_state]
        for edge in rev_graph.neighbors(current_node):
            if edge.departure > current_time:
                continue
            neighbor_state = (edge.target, edge.line)
            transfer_cost = 0
            if current_line is not None and edge.line != current_line:
                transfer_cost = transfer_penalty

            departure_time = edge.departure - edge.travel_time * time_weight
            tentative_time = departure_time - transfer_cost
            arrival_actual = edge.departure - edge.travel_time

            if tentative_time > best_time.get(neighbor_state, float("-inf")):
                came_from[neighbor_state] = (current_node, current_line)
                best_time[neighbor_state] = tentative_time
                arrival_times[neighbor_state] = arrival_actual
                f_score = -tentative_time + heuristic(edge.target, start)
                heapq.heappush(
                    open_set,
                    PrioritizedItem(priority=f_score, node=neighbor_state),
                )

    return None

# Example heuristic: straight-line distance (requires coordinate lookup)
def null_heuristic(node: str, goal: str) -> float:
    return 0

if __name__ == "__main__":
    # Load graph from CSV file. Fallback to the test file if the full file is
    # not present.
    csv_file = r"Vollständige_CSV_mit_Zeiten.csv"
    try:
        graph = load_graph_from_csv(csv_file)
    except FileNotFoundError:
        print(f"CSV '{csv_file}' not found. Using test data instead.")
        graph = load_graph_from_csv("Test_CSV_with_travel_times.csv")

    stop_names = list(graph.nodes.keys())

    while True:
        start_query = input("Start stop name (or 'reset'/'exit'): ").strip()
        if start_query.lower() == "exit":
            break
        if start_query.lower() == "reset":
            continue
        start = resolve_stop(start_query, stop_names)
        if start is None:
            print(f"Unknown stop: {start_query}")
            continue

        goal_query = input("Goal stop name (or 'reset'/'exit'): ").strip()
        if goal_query.lower() == "exit":
            break
        if goal_query.lower() == "reset":
            continue
        goal = resolve_stop(goal_query, stop_names)
        if goal is None:
            print(f"Unknown stop: {goal_query}")
            continue

        choice_time = input("Zeit wählen [now/abfahrt/anreise] (or 'reset'/'exit'): ").strip().lower()
        if choice_time == "exit":
            break
        if choice_time == "reset":
            continue
        if choice_time == "now":
            now = datetime.now()
            start_minutes = now.hour * 60 + now.minute + now.second / 60.0
            reverse = False
        elif choice_time == "abfahrt":
            dep_str = input("Abfahrtszeit (HH:MM) (or 'reset'/'exit'): ").strip()
            if dep_str.lower() == "exit":
                break
            if dep_str.lower() == "reset":
                continue
            start_minutes = parse_time_to_minutes(dep_str)
            reverse = False
        elif choice_time == "anreise":
            arr_str = input("Ankunftszeit (HH:MM) (or 'reset'/'exit'): ").strip()
            if arr_str.lower() == "exit":
                break
            if arr_str.lower() == "reset":
                continue
            start_minutes = parse_time_to_minutes(arr_str)
            reverse = True
        else:
            print("Ungültige Wahl, benutze aktuelle Zeit.")
            now = datetime.now()
            start_minutes = now.hour * 60 + now.minute + now.second / 60.0
            reverse = False

        choice = input("Sort route by time or transfers? [time/transfers] (or 'reset'/'exit'): ").strip().lower()
        if choice == "exit":
            break
        if choice == "reset":
            continue
        if choice.startswith("time"):
            time_weight = 1.0
            penalty = 0.1
        elif choice.startswith("transfers"):
            time_weight = 0.0
            penalty = 1.0
        else:
            print("Invalid choice. Defaulting to time.")
            time_weight = 1.0
            penalty = 0.1


        if reverse:
            path = astar_reverse(
                graph,
                start,
                goal,
                heuristic=null_heuristic,
                arrival_time=start_minutes,
                time_weight=time_weight,
                transfer_penalty=penalty,
            )
        else:
            path = astar(
                graph,
                start,
                goal,
                heuristic=null_heuristic,
                start_time=start_minutes,
                time_weight=time_weight,
                transfer_penalty=penalty,
            )

        if path:
            print("Found path:")
            start_stop = path[0][0]
            print(f"Start at {start_stop}")
            for step in path[1:]:
                if len(step) == 3:
                    stop, line, arr = step
                    line_str = line if line is not None else "start"
                    print(f"Take {line_str} to {stop} arriving at {minutes_to_hhmm(arr)}")
                else:
                    stop, line = step
                    line_str = line if line is not None else "start"
                    print(f"Take {line_str} to {stop}")
        else:
            print("No path found.")


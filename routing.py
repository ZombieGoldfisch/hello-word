from dataclasses import dataclass, field
from typing import Any, Callable, Dict, List, Optional, Tuple
import heapq
import csv
import difflib

from graph import Graph


@dataclass(order=True)
class PrioritizedItem:
    priority: float
    node: Any = field(compare=False)


def parse_travel_time(td_str: str) -> float:
    """Convert a ``travel_time_to_next_stop`` string to minutes."""
    if not td_str:
        return 0.0

    parts = td_str.strip().split(" days ")
    if len(parts) == 2:
        days, time_part = parts
    else:
        days, time_part = "0", parts[0]

    time_parts = time_part.split(":")
    if len(time_parts) == 3:
        hours, minutes, seconds = map(int, time_parts)
    elif len(time_parts) == 2:
        hours, minutes = map(int, time_parts)
        seconds = 0
    else:
        raise ValueError(f"Invalid time format: {td_str}")

    return int(days) * 1440 + hours * 60 + minutes + seconds / 60.0


def parse_time_to_minutes(time_str: str) -> float:
    """Parse a ``departure_time`` or ``arrival_time`` field to minutes."""
    return parse_travel_time(time_str)


def minutes_to_hhmm(minutes: float) -> str:
    """Format minutes past midnight as ``HH:MM``."""
    minutes = minutes % (24 * 60)
    hours = int(minutes // 60)
    mins = int(minutes % 60)
    return f"{hours:02d}:{mins:02d}"


def resolve_stop(query: str, stop_names: List[str], cutoff: float = 0.6) -> Optional[str]:
    """Return the closest matching stop name for ``query`` or ``None``."""
    matches = difflib.get_close_matches(query, stop_names, n=1, cutoff=cutoff)
    return matches[0] if matches else None


def load_graph_from_csv(path: str) -> Graph:
    """Create a graph from a CSV generated by GTFS with travel times."""
    g = Graph()
    with open(path, newline="", encoding="utf-8") as fh:
        reader = csv.DictReader(fh)
        prev_row = None
        for row in reader:
            if prev_row and row["trip_id"] == prev_row["trip_id"]:
                source = prev_row["stop_name"]
                target = row["stop_name"]
                line = row["route_short_name"]
                travel_time = parse_travel_time(prev_row["travel_time_to_next_stop"])
                departure = parse_time_to_minutes(prev_row["departure_time"])
                s_lat = float(prev_row["stop_lat"]) if prev_row["stop_lat"] else None
                s_lon = float(prev_row["stop_lon"]) if prev_row["stop_lon"] else None
                t_lat = float(row["stop_lat"]) if row["stop_lat"] else None
                t_lon = float(row["stop_lon"]) if row["stop_lon"] else None
                g.add_edge(
                    source,
                    target,
                    line,
                    departure,
                    travel_time,
                    s_lat,
                    s_lon,
                    t_lat,
                    t_lon,
                )
            prev_row = row
    return g


def astar(
    graph: Graph,
    start: str,
    goal: str,
    heuristic: Callable[[str, str], float],
    start_time: float,
    time_weight: float = 1.0,
    transfer_penalty: float = 5.0,
) -> Optional[List[Tuple[str, Optional[str], float]]]:
    """Compute shortest path using A* algorithm with line awareness."""
    open_set: List[PrioritizedItem] = []
    start_state = (start, None)
    heapq.heappush(open_set, PrioritizedItem(priority=start_time, node=start_state))

    came_from: Dict[Tuple[str, Optional[str]], Optional[Tuple[str, Optional[str]]]] = {}
    g_score: Dict[Tuple[str, Optional[str]], float] = {start_state: start_time}
    arrival_times: Dict[Tuple[str, Optional[str]], float] = {start_state: start_time}

    while open_set:
        current_state = heapq.heappop(open_set).node
        current_node, current_line = current_state
        if current_node == goal:
            path = []
            while True:
                arr = arrival_times[current_state]
                stop, line = current_state
                path.append((stop, line, arr))
                prev = came_from.get(current_state)
                if prev is None:
                    break
                current_state = prev
            return list(reversed(path))

        current_arrival = arrival_times[(current_node, current_line)]
        for edge in graph.neighbors(current_node):
            if edge.departure < current_arrival:
                continue
            neighbor_state = (edge.target, edge.line)
            transfer_cost = 0
            if current_line is not None and edge.line != current_line:
                transfer_cost = transfer_penalty

            arrival_actual = edge.departure + edge.travel_time
            arrival_time = edge.departure + edge.travel_time * time_weight
            tentative_g_score = arrival_time + transfer_cost

            if tentative_g_score < g_score.get(neighbor_state, float("inf")):
                came_from[neighbor_state] = (current_node, current_line)
                g_score[neighbor_state] = tentative_g_score
                arrival_times[neighbor_state] = arrival_actual
                f_score = tentative_g_score + heuristic(edge.target, goal)
                heapq.heappush(
                    open_set,
                    PrioritizedItem(priority=f_score, node=neighbor_state),
                )

    return None


def astar_reverse(
    graph: Graph,
    start: str,
    goal: str,
    heuristic: Callable[[str, str], float],
    arrival_time: float,
    time_weight: float = 1.0,
    transfer_penalty: float = 5.0,
) -> Optional[List[Tuple[str, Optional[str], float]]]:
    """Backward search variant of ``astar``."""
    rev_graph = graph.reversed()

    open_set: List[PrioritizedItem] = []
    start_state = (goal, None)
    heapq.heappush(open_set, PrioritizedItem(priority=-arrival_time, node=start_state))

    came_from: Dict[Tuple[str, Optional[str]], Optional[Tuple[str, Optional[str]]]] = {}
    best_time: Dict[Tuple[str, Optional[str]], float] = {start_state: arrival_time}
    arrival_times: Dict[Tuple[str, Optional[str]], float] = {start_state: arrival_time}

    while open_set:
        current_state = heapq.heappop(open_set).node
        current_node, current_line = current_state
        if current_node == start:
            path: List[Tuple[str, Optional[str], float]] = []
            next_line: Optional[str] = current_state[1]
            while True:
                arr = arrival_times[current_state]
                stop, line = current_state
                path.append((stop, None if not path else next_line, arr))
                next_line = line
                prev = came_from.get(current_state)
                if prev is None:
                    break
                current_state = prev
            return path

        current_time = best_time[current_state]
        for edge in rev_graph.neighbors(current_node):
            if edge.departure > current_time:
                continue
            neighbor_state = (edge.target, edge.line)
            transfer_cost = 0
            if current_line is not None and edge.line != current_line:
                transfer_cost = transfer_penalty

            departure_time = edge.departure - edge.travel_time * time_weight
            tentative_time = departure_time - transfer_cost
            arrival_actual = edge.departure - edge.travel_time

            if tentative_time > best_time.get(neighbor_state, float("-inf")):
                came_from[neighbor_state] = (current_node, current_line)
                best_time[neighbor_state] = tentative_time
                arrival_times[neighbor_state] = arrival_actual
                f_score = -tentative_time + heuristic(edge.target, start)
                heapq.heappush(
                    open_set,
                    PrioritizedItem(priority=f_score, node=neighbor_state),
                )

    return None


def null_heuristic(node: str, goal: str) -> float:
    return 0


def load_default_graph(
    csv_file: str = "VollstÃ¤ndige_CSV_mit_Zeiten.csv",
    fallback: str = "Test_CSV_with_travel_times.csv",
) -> Graph:
    """Load the transit graph, falling back to a small test file."""
    try:
        return load_graph_from_csv(csv_file)
    except FileNotFoundError:
        print(f"CSV '{csv_file}' not found. Using test data instead.")
        return load_graph_from_csv(fallback)


def find_route(
    graph: Graph,
    start: str,
    goal: str,
    start_minutes: float,
    *,
    reverse: bool = False,
    sort_by: str = "time",
    heuristic: Callable[[str, str], float] = null_heuristic,
) -> Optional[List[Tuple[str, Optional[str], float]]]:
    """Return a route computed by ``astar`` or ``astar_reverse``."""
    if sort_by.startswith("time"):
        time_weight = 1.0
        penalty = 0.1
    elif sort_by.startswith("transfers"):
        time_weight = 0.0
        penalty = 1.0
    else:
        raise ValueError(f"Invalid sort mode: {sort_by}")

    if reverse:
        return astar_reverse(
            graph,
            start,
            goal,
            heuristic=heuristic,
            arrival_time=start_minutes,
            time_weight=time_weight,
            transfer_penalty=penalty,
        )
    else:
        return astar(
            graph,
            start,
            goal,
            heuristic=heuristic,
            start_time=start_minutes,
            time_weight=time_weight,
            transfer_penalty=penalty,
        )
